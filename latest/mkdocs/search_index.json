{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction to CTriangle\n\n\nCTriagle works as an interface for \nTriangle\n library by \nJonathan Shewchuk\n. Please refer to the triangle site where you can findout more about what you can do with Triangle. Specifically read the following sections.\n\n\n\n\nTriangle demonstration\n\n\ninput files \n.node\n, \n.poly\n, \n.area\n and \n.ele\n.\n\n\ncommand line switches\n\n\n\n\nNote that currently generation of the Voronoi diagram is not supported (switch -v) in CTriangle.\n\n\nCTriangle can also generate graph of given triangulation for Latex package \nPGFPlots\n.\n\n\n\n\nCurrent status\n\n\nCTriangle currently runs on Julia versions 0.5.\n\n\n\n\nInstallation and basic usage\n\n\nInstall the package as follows:\n\n\nPkg.clone(\nhttps://github.com/kuzmamar/CTriangle.jl\n)\nPkg.build(\nCTriangle.jl\n)\nPkg.test(\nCTriangle.jl\n)\n\n\n\n\nand to use it:\n\n\nusing CTriangle\n\n\n\n\n\n\nInterface for generating triangulations\n\n\n#\n\n\nCTriangle.triangulate\n \n \nFunction\n.\n\n\ntriangulate(fileName::String, options::String = \n)\n\n\n\n\nFirst argument is a path to input file. Second argument is a list of command line switches. Returns desired triangulation.\n\n\nsource\n\n\ntriangulate(points::Matrix{Cdouble}, options::String = \n)\n\n\n\n\nFirst argument is a matrix of vertices. First row of the matrix are x-cordinates. Second row stores y-coordinates. Returns Delaunay triangulation.\n\n\nsource\n\n\ntriangulate(points::Matrix{Int}, options::String = \n)\n\n\n\n\nFirst argument is a matrix of vertices. First row of the matrix are x-cordinates. Second row stores y-coordinates. Second argument are command line switches. Returns Delaunay triangulation.\n\n\nsource\n\n\n\n\nInterface for outputing a graph\n\n\n#\n\n\nCTriangle.outputGraph\n \n \nFunction\n.\n\n\noutputGraph(\n    riangulation::TriangulationInterface, directory::String;\n    nodesDataFileName::String = NODES_OUTPUT_DATA_FILE_NAME,\n    edgesDataFileName::String = EDGES_OUTPUT_DATA_FILE_NAME,\n    elemesDataFileName::String = ELEMS_OUTPUT_DATA_FILE_NAME,\n    segmentsDataFileName::String = SEGMENTS_OUTPUT_DATA_FILE_NAME,\n    triangulationFileName::String = TRIANGULATION_OUTPUT_FILE_NAME,\n    displayAxis::Bool = false\n)\n\n\n\n\nFirst argument is a triangulation returned form triangulate function. Second argument is a path to a directory where we want to store the graph in .tex file. Optionally you can specify name for each .dat file and resulting .tex file.\n\n\nArgument nodesDataFileName is a name for vertices .dat file. Argument edgesDataFileName is a name for edges .dat file. Argument elemesDataFileName is a name for elements (triangles) .dat file. Argument segmentsDataFileName is a name for segments .dat file. Argument triangulationFileName is a name for graph .tex file. Argument displayAxis tells if we want to display axis around the graph. All .dat files and .tex file will be stored in the given directory.\n\n\nsource\n\n\n\n\nTriangulation interface\n\n\nEach triangulation implements following functions.\n\n\n#\n\n\nCTriangle.getNode\n \n \nFunction\n.\n\n\ngetNode(triangulation::TriangulationInterface, index::Int)\n\n\n\n\nReturns a vertex with a given index.\n\n\nsource\n\n\n#\n\n\nCTriangle.getNodes\n \n \nFunction\n.\n\n\ngetNodes(triangulation::TriangulationInterface)\n\n\n\n\nReturns an iterator to a list of vertices.\n\n\nsource\n\n\n#\n\n\nCTriangle.getSegments\n \n \nFunction\n.\n\n\ngetSegments(triangulation::TriangulationInterface)\n\n\n\n\nReturns an iterator to a list of segments.\n\n\nsource\n\n\n#\n\n\nCTriangle.getElement\n \n \nFunction\n.\n\n\ngetElement(triangulation::TriangulationInterface, index::Int)\n\n\n\n\nReturns a triangle with a given index.\n\n\nsource\n\n\n#\n\n\nCTriangle.getElements\n \n \nFunction\n.\n\n\ngetElements(triangulation::TriangulationInterface)\n\n\n\n\nReturns an iterator to a list of triangles.\n\n\nsource\n\n\n#\n\n\nCTriangle.getEdges\n \n \nFunction\n.\n\n\ngetEdges(triangulation::TriangulationInterface)\n\n\n\n\nReturns an iterator to a list of edges.\n\n\nsource\n\n\n#\n\n\nCTriangle.getNeighbors\n \n \nFunction\n.\n\n\ngetNeighbors(triangulation::TriangulationInterface, element::Element)\n\n\n\n\nReturns list of triangles that are neighbors to the given triangle.\n\n\nsource\n\n\nConstrained Delaunay triangulations implement also these functions.\n\n\n#\n\n\nCTriangle.getHoles\n \n \nFunction\n.\n\n\ngetHoles(triangulation::ConstrainedTriangulationInterface)\n\n\n\n\nReturns an iterator to a list of holes.\n\n\nsource\n\n\n#\n\n\nCTriangle.getRegions\n \n \nFunction\n.\n\n\ngetRegions(triangulation::ConstrainedDelaunayTriangulation)\n\n\n\n\nReturns an iterator to a list of regions.\n\n\nsource", 
            "title": "Introduction to CTriangle"
        }, 
        {
            "location": "/#introduction-to-ctriangle", 
            "text": "CTriagle works as an interface for  Triangle  library by  Jonathan Shewchuk . Please refer to the triangle site where you can findout more about what you can do with Triangle. Specifically read the following sections.   Triangle demonstration  input files  .node ,  .poly ,  .area  and  .ele .  command line switches   Note that currently generation of the Voronoi diagram is not supported (switch -v) in CTriangle.  CTriangle can also generate graph of given triangulation for Latex package  PGFPlots .", 
            "title": "Introduction to CTriangle"
        }, 
        {
            "location": "/#current-status", 
            "text": "CTriangle currently runs on Julia versions 0.5.", 
            "title": "Current status"
        }, 
        {
            "location": "/#installation-and-basic-usage", 
            "text": "Install the package as follows:  Pkg.clone( https://github.com/kuzmamar/CTriangle.jl )\nPkg.build( CTriangle.jl )\nPkg.test( CTriangle.jl )  and to use it:  using CTriangle", 
            "title": "Installation and basic usage"
        }, 
        {
            "location": "/#interface-for-generating-triangulations", 
            "text": "#  CTriangle.triangulate     Function .  triangulate(fileName::String, options::String =  )  First argument is a path to input file. Second argument is a list of command line switches. Returns desired triangulation.  source  triangulate(points::Matrix{Cdouble}, options::String =  )  First argument is a matrix of vertices. First row of the matrix are x-cordinates. Second row stores y-coordinates. Returns Delaunay triangulation.  source  triangulate(points::Matrix{Int}, options::String =  )  First argument is a matrix of vertices. First row of the matrix are x-cordinates. Second row stores y-coordinates. Second argument are command line switches. Returns Delaunay triangulation.  source", 
            "title": "Interface for generating triangulations"
        }, 
        {
            "location": "/#interface-for-outputing-a-graph", 
            "text": "#  CTriangle.outputGraph     Function .  outputGraph(\n    riangulation::TriangulationInterface, directory::String;\n    nodesDataFileName::String = NODES_OUTPUT_DATA_FILE_NAME,\n    edgesDataFileName::String = EDGES_OUTPUT_DATA_FILE_NAME,\n    elemesDataFileName::String = ELEMS_OUTPUT_DATA_FILE_NAME,\n    segmentsDataFileName::String = SEGMENTS_OUTPUT_DATA_FILE_NAME,\n    triangulationFileName::String = TRIANGULATION_OUTPUT_FILE_NAME,\n    displayAxis::Bool = false\n)  First argument is a triangulation returned form triangulate function. Second argument is a path to a directory where we want to store the graph in .tex file. Optionally you can specify name for each .dat file and resulting .tex file.  Argument nodesDataFileName is a name for vertices .dat file. Argument edgesDataFileName is a name for edges .dat file. Argument elemesDataFileName is a name for elements (triangles) .dat file. Argument segmentsDataFileName is a name for segments .dat file. Argument triangulationFileName is a name for graph .tex file. Argument displayAxis tells if we want to display axis around the graph. All .dat files and .tex file will be stored in the given directory.  source", 
            "title": "Interface for outputing a graph"
        }, 
        {
            "location": "/#triangulation-interface", 
            "text": "Each triangulation implements following functions.  #  CTriangle.getNode     Function .  getNode(triangulation::TriangulationInterface, index::Int)  Returns a vertex with a given index.  source  #  CTriangle.getNodes     Function .  getNodes(triangulation::TriangulationInterface)  Returns an iterator to a list of vertices.  source  #  CTriangle.getSegments     Function .  getSegments(triangulation::TriangulationInterface)  Returns an iterator to a list of segments.  source  #  CTriangle.getElement     Function .  getElement(triangulation::TriangulationInterface, index::Int)  Returns a triangle with a given index.  source  #  CTriangle.getElements     Function .  getElements(triangulation::TriangulationInterface)  Returns an iterator to a list of triangles.  source  #  CTriangle.getEdges     Function .  getEdges(triangulation::TriangulationInterface)  Returns an iterator to a list of edges.  source  #  CTriangle.getNeighbors     Function .  getNeighbors(triangulation::TriangulationInterface, element::Element)  Returns list of triangles that are neighbors to the given triangle.  source  Constrained Delaunay triangulations implement also these functions.  #  CTriangle.getHoles     Function .  getHoles(triangulation::ConstrainedTriangulationInterface)  Returns an iterator to a list of holes.  source  #  CTriangle.getRegions     Function .  getRegions(triangulation::ConstrainedDelaunayTriangulation)  Returns an iterator to a list of regions.  source", 
            "title": "Triangulation interface"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nLet's say we want a Delaunay triangulation of the following spiral.\n\n\n\n\nTo do that, we create a file with .node extension (for eample \nspiral.node\n), that represents the spiral. We can now compute a Delaunay triangulation of the spiral and generate it's graph.\n\n\nusing CTriangle\n\nt = triangulate(\nspiral.node\n)\noutputGraph(t, \n/home/martin/spiral\n)\n\n\n\n\nRun the following command form command line if you want to see the graph. It will store a \"triangulation.pdf\" in the current working directory.\n\n\npdflatex /home/martin/spiral/triangulation.tex\n\n\n\n\nThe graph from the example above:\n\n\n\n\nNext example shows how we can refine an existing mesh. Let's say we have the mesh stored in \nbox.node\n and \nele.node\n. The following image shows the mesh.\n\n\n\n\nNow imagine that we want one particular triangle to have area not bigger than 0.2. For this we create \nbox.area\n file. Now it can be refined in CTriangle:\n\n\nusing CTriangle\n\nt = triangulate(\nbox\n, \nra\n)\noutputGraph(t, \n/home/martin/example2\n)\n\n\n\n\nNote that we dont have to specify file extension. CTriangle knows which files to read from the command line switches. The refined mesh is shown on the image below.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Let's say we want a Delaunay triangulation of the following spiral.   To do that, we create a file with .node extension (for eample  spiral.node ), that represents the spiral. We can now compute a Delaunay triangulation of the spiral and generate it's graph.  using CTriangle\n\nt = triangulate( spiral.node )\noutputGraph(t,  /home/martin/spiral )  Run the following command form command line if you want to see the graph. It will store a \"triangulation.pdf\" in the current working directory.  pdflatex /home/martin/spiral/triangulation.tex  The graph from the example above:   Next example shows how we can refine an existing mesh. Let's say we have the mesh stored in  box.node  and  ele.node . The following image shows the mesh.   Now imagine that we want one particular triangle to have area not bigger than 0.2. For this we create  box.area  file. Now it can be refined in CTriangle:  using CTriangle\n\nt = triangulate( box ,  ra )\noutputGraph(t,  /home/martin/example2 )  Note that we dont have to specify file extension. CTriangle knows which files to read from the command line switches. The refined mesh is shown on the image below.", 
            "title": "Examples"
        }
    ]
}